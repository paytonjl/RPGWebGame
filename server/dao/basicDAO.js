import mongodb from "mongodb"
//const ObjectID = mongodb.ObjectID not using it i think this will allow us to work with object ids that are auto created in the object

// Basic class for accessing the MongoDatabase. This is meant to be extended by 
// more specific classes
export default class BasicDAO {
    
    constructor(client) {
        this.mongoDatabase = null;
    }
    
    /**
     * The function injectDB asynchronously establishes a connection to a MongoDB
     * database collection for an RPG game.
     * @param client - The `client` parameter in the `injectDB` method is an
     * instance of a MongoDB client that is used to connect to the MongoDB database.
     * This client is used to interact with the database, perform operations such as
     * querying, inserting, updating, and deleting data.
     * @returns If the `mongoDatabase` variable is already defined, the function will
     * return without doing anything.
     */
    async injectDB(client) {
        if (this.mongoDatabase) {
            return
        }
        try { 
            this.mongoDatabase = await client.db("MyRPG").collection("accounts")
        } catch (e) {
            console.error(`Unable to establish collection handles in userDAO: ${e}`)
        }
    }

    /** 
     * Is the user currently logged into an account in the database?
     * Do the current sessionId and clientIpAddress match any of the user accounts
     * in the database? 
     * @param sessionId - sessionId generated by the user whenever they access 
     * the website. 
     * @param clientIpAddress - the IP address of the user.
     * @returns true when user's IP address and session ID match a user account
     * in the database
     * */ 
    async validateSessionId(sessionId, clientIpAddress)
    {
        try {
            let userAccount = await this.mongoDatabase.findOne({currentSessionId: sessionId});

            if(!userAccount)
            {
                console.log("Couldn't find user account associated with id " + sessionId);
                return false;
            }
            
            if(!userAccount.currentSessionId || !userAccount.currentSessionIpAddress)
            {
                console.log("currentSessionId or currentSessionIpAddress missing for " + sessionId);
                return false;
            }
            
            if( clientIpAddress == userAccount.currentSessionIpAddress &&
                sessionId == userAccount.currentSessionId) {
                return true;
            }
            else {
                console.log("no match client IP: " + clientIpAddress + " last IP: " + userAccount.currentSessionIpAddress + " client session id " + sessionId + " last sessionId " + userAccount.currentSessionId );
                return false;
            }
        } catch (e) {
            console.log(e.message)
        }

        return false;
    }

    // Gets the value of the key matching dataFetchCommand in the the user's account.
    // Returns just the user's account ID if not found. dataFetchCommand must be the form
    // { projection: { "dataToFind.subDataToFind": 1} }
    async fetchFromAccount(sessionId, currentIpAddress, dataFetchCommand)
    {
        try{
            let userAccount = await this.mongoDatabase.findOne({currentSessionId: sessionId});
            
            if(!userAccount)
            {
                console.log("Couldn't find user account associated with id " + sessionId);
                return false;
            }

            if(!userAccount.currentSessionId || !userAccount.currentSessionIpAddress)
            {
                console.log("currentSessionId or currentSessionIpAddress missing for " + sessionId);
                return false;
            }

            if( currentIpAddress != userAccount.currentSessionIpAddress ||
                sessionId != userAccount.currentSessionId) {
                console.log("Credentials don't match up");
                return false;
            }
            const response = await this.mongoDatabase.findOne({currentSessionId: sessionId},
                dataFetchCommand);

            return response;
        } catch (e) {
            console.log(e.message);
        }
    }

    // User must have already logged in and have a session whose sessionId matches the currentSessionId field of their mongodb account
    // currentSessionIpAddress must also match
    async updateUserAccount(sessionId, currentIpAddress, command)
    {
        try{
            let userAccount = await this.mongoDatabase.findOne({currentSessionId: sessionId});

            if(!userAccount)
            {
                console.log("Couldn't find user account associated with id " + sessionId);
                return false;
            }

            if(!userAccount.currentSessionId || !userAccount.currentSessionIpAddress)
            {
                console.log("currentSessionId or currentSessionIpAddress missing for " + sessionId);
                return false;
            }

            if( currentIpAddress != userAccount.currentSessionIpAddress ||
                sessionId != userAccount.currentSessionId) {
                console.log("Credentials don't match up");
                return false;
            }

            const response = await this.mongoDatabase.updateOne({currentSessionId: sessionId }, 
                command,
                (err, result) => {
                    if (err) {
                        console.error("Not found" + err);
                    } else {
                        console.log("Update success!")
                    }
                });
        } catch (e) {
            console.log(e.message)
        }
    }
}